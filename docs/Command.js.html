
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <title>Command.js - Documentation</title>
    <meta charset="UTF-8">

    <!--Import Google Icon Font-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <!--Import materialize.css-->
    <link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"  media="screen,projection" />
    <link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism-okaidia.min.css" />
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

    <!--Let browser know website is optimized for mobile-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body class="blue-grey darken-4">
    <header>
      <nav class="blue-grey darken-3">
        <a href="#" data-target="slide-out" class="sidenav-trigger"><i class="material-icons">menu</i></a>
        
      </nav>
    </header>
    <ul id="slide-out" class="sidenav sidenav-fixed">
      <li><h3>Classes</h3></li><li id="Command-nav"><ul class="collapsible collapsible-accordion"><li><a class="collapsible-header"><i class="material-icons if-unactive">arrow_drop_down</i><i class="material-icons if-active">arrow_drop_up</i></a><a href="Command.html">Command</a><div class="collapsible-body"><ul class='methods'><li data-type="method" id="Command-addSubCommand-nav"><a href="Command.html#addSubCommand">addSubCommand</a></li><li data-type="method" id="Command-getAliases-nav"><a href="Command.html#getAliases">getAliases</a></li><li data-type="method" id="Command-getDescription-nav"><a href="Command.html#getDescription">getDescription</a></li><li data-type="method" id="Command-getExecutor-nav"><a href="Command.html#getExecutor">getExecutor</a></li><li data-type="method" id="Command-getParent-nav"><a href="Command.html#getParent">getParent</a></li><li data-type="method" id="Command-getPermissionRequired-nav"><a href="Command.html#getPermissionRequired">getPermissionRequired</a></li><li data-type="method" id="Command-getSubCommand-nav"><a href="Command.html#getSubCommand">getSubCommand</a></li><li data-type="method" id="Command-getSubCommands-nav"><a href="Command.html#getSubCommands">getSubCommands</a></li><li data-type="method" id="Command-getTabCompleter-nav"><a href="Command.html#getTabCompleter">getTabCompleter</a></li><li data-type="method" id="Command-getUsage-nav"><a href="Command.html#getUsage">getUsage</a></li><li data-type="method" id="Command-handleExecution-nav"><a href="Command.html#handleExecution">handleExecution</a></li><li data-type="method" id="Command-hasParent-nav"><a href="Command.html#hasParent">hasParent</a></li><li data-type="method" id="Command-hasSubCommand-nav"><a href="Command.html#hasSubCommand">hasSubCommand</a></li><li data-type="method" id="Command-matchesName-nav"><a href="Command.html#matchesName">matchesName</a></li><li data-type="method" id="Command-onTabComplete-nav"><a href="Command.html#onTabComplete">onTabComplete</a></li><li data-type="method" id="Command-removeSubCommand-nav"><a href="Command.html#removeSubCommand">removeSubCommand</a></li><li data-type="method" id="Command-setAliases-nav"><a href="Command.html#setAliases">setAliases</a></li><li data-type="method" id="Command-setDescription-nav"><a href="Command.html#setDescription">setDescription</a></li><li data-type="method" id="Command-setExecutor-nav"><a href="Command.html#setExecutor">setExecutor</a></li><li data-type="method" id="Command-setParent-nav"><a href="Command.html#setParent">setParent</a></li><li data-type="method" id="Command-setPermissionRequired-nav"><a href="Command.html#setPermissionRequired">setPermissionRequired</a></li><li data-type="method" id="Command-setTabCompleter-nav"><a href="Command.html#setTabCompleter">setTabCompleter</a></li><li data-type="method" id="Command-setUsage-nav"><a href="Command.html#setUsage">setUsage</a></li></ul></div></li></ul></li><li id="CommandBuilder-nav"><ul class="collapsible collapsible-accordion"><li><a class="collapsible-header"><i class="material-icons if-unactive">arrow_drop_down</i><i class="material-icons if-active">arrow_drop_up</i></a><a href="CommandBuilder.html">CommandBuilder</a><div class="collapsible-body"><ul class='methods'><li data-type="method" id="CommandBuilder-build-nav"><a href="CommandBuilder.html#build">build</a></li><li data-type="method" id="CommandBuilder-setAliases-nav"><a href="CommandBuilder.html#setAliases">setAliases</a></li><li data-type="method" id="CommandBuilder-setDescription-nav"><a href="CommandBuilder.html#setDescription">setDescription</a></li><li data-type="method" id="CommandBuilder-setExecutor-nav"><a href="CommandBuilder.html#setExecutor">setExecutor</a></li><li data-type="method" id="CommandBuilder-setPermissionRequired-nav"><a href="CommandBuilder.html#setPermissionRequired">setPermissionRequired</a></li><li data-type="method" id="CommandBuilder-setTabCompleter-nav"><a href="CommandBuilder.html#setTabCompleter">setTabCompleter</a></li><li data-type="method" id="CommandBuilder-setUsage-nav"><a href="CommandBuilder.html#setUsage">setUsage</a></li></ul></div></li></ul></li><li id="CommandManager-nav"><ul class="collapsible collapsible-accordion"><li><a class="collapsible-header"><i class="material-icons if-unactive">arrow_drop_down</i><i class="material-icons if-active">arrow_drop_up</i></a><a href="CommandManager.html">CommandManager</a><div class="collapsible-body"><ul class='methods'><li data-type="method" id="CommandManager-clearCommands-nav"><a href="CommandManager.html#clearCommands">clearCommands</a></li><li data-type="method" id="CommandManager-getCommand-nav"><a href="CommandManager.html#getCommand">getCommand</a></li><li data-type="method" id="CommandManager-getCommands-nav"><a href="CommandManager.html#getCommands">getCommands</a></li><li data-type="method" id="CommandManager-hasCommand-nav"><a href="CommandManager.html#hasCommand">hasCommand</a></li><li data-type="method" id="CommandManager-register-nav"><a href="CommandManager.html#register">register</a></li></ul></div></li></ul></li><li id="CommandResult-nav"><ul class="collapsible collapsible-accordion"><li><a class="collapsible-header"><i class="material-icons if-unactive">arrow_drop_down</i><i class="material-icons if-active">arrow_drop_up</i></a><a href="CommandResult.html">CommandResult</a><div class="collapsible-body"><ul class='methods'><li data-type="method" id="CommandResult-call-nav"><a href="CommandResult.html#call">call</a></li></ul></div></li></ul></li><li id="ResourceName-nav"><ul class="collapsible collapsible-accordion"><li><a class="collapsible-header"><i class="material-icons if-unactive">arrow_drop_down</i><i class="material-icons if-active">arrow_drop_up</i></a><a href="ResourceName.html">ResourceName</a><div class="collapsible-body"><ul class='methods'><li data-type="method" id="ResourceName-equals-nav"><a href="ResourceName.html#equals">equals</a></li><li data-type="method" id="ResourceName-toString-nav"><a href="ResourceName.html#toString">toString</a></li></ul></div></li></ul></li>
    </ul>
    <main>
      
        <h1 class="page-title center white-text light">
          Command.js
        </h1>
      
      
    <section>
  <article>
    <pre><code class="lang-js">
      /*
 * Copyright Â© 2018 AperLambda &lt;aperlambda@gmail.com>
 *
 * This file is part of kimiko.js.
 *
 * Licensed under the MIT license. For more information,
 * see the LICENSE file.
 */

const CommandResult = require("./CommandResult");
const ResourceName = require("./ResourceName");

/**
 * The Command class, represents an executable command. It handles usage definition, subcommands, tab completion and aliases.
 */
class Command
{

  /**
   * @param {(String|ResourceName)} name Name of the Command
   * @param {Command=} parent Parent Command, used by {@link Command#addSubCommand}
   */
  constructor(name, parent)
  {
    this.name = new ResourceName(name);
    if (parent) {
      this.setParent(parent);
    }
    this.usage = null;
    this.description = null;
    this.aliases = [];
    this.permissionRequired = "";
    this.executor = null;
    this.tabCompleter = null;
    this.subCommands = [];
  }

  /**
   * Returns the parent command, if set
   * @return {?Command}
   */
  getParent()
  {
    return this.parent;
  }

  /**
   * Sets the parent command
   * @param {Command} parent
   */
  setParent(parent)
  {
    this.parent = parent;
  }

  /**
   * Returns whether or not the command is a child command
   * @return {boolean}
   */
  hasParent()
  {
    return !!this.parent;
  }

  /**
   * Returns the usage of the command
   * @param {*=} sender The sender/author-representing object, will be passed to the {@link Command~usageCallback}
   * @return {String}
   */
  getUsage(sender)
  {
    if (typeof this.usage == "function") {
      return this.usage(sender);
    }
    return this.usage;
  }

  /**
   * Sets the usage for the command
   * @param {(String|Command~usageCallback)} usage
   * @throws Will throw an Error if `usage` is neither a string nor a function
   */
  setUsage(usage)
  {
    if (typeof usage == "string") {
      this.usage = usage.replace("&lt;command>", this.name);
    } else if (typeof usage == "function") {
      this.usage = usage;
    } else {
      throw new Error(`kimiko.js, Command::setUsage(usage): 'usage' should be either a string, or a function, got ${typeof usage}.`);
    }
  }


  /**
   * Returns the description of the command
   * @param {*=} sender If {@link Command#description} is a function, it will call this function with `sender` as argument. Represents the sender/author of the command call
   * @return {String}
   */
  getDescription(sender)
  {
    if (typeof this.description == "function") {
      return String(this.description(sender));
    }
    return this.description; // TODO: default description?
  }

  /**
   * Sets the description of a command
   * @param {(String|Command~descriptionCallback)} description
   * @throws Will throw an Error if `description` is neither a string nor a function
   */
  setDescription(description)
  {
    if (typeof description == "string" || typeof description == "function") {
      this.description = description;
    } else {
      throw new Error(`kimiko.js, Command::setDescription(description): 'description' should be either a string, or a function, got ${typeof description}.`);
    }
  }

  /**
   * Returns all the aliases
   * @return {String[]}
   */
  getAliases()
  {
    return this.aliases;
  }

  /**
   * Adds aliases to the `Command`
   * @param {...(String|String[])} aliases
   */
  setAliases(...aliases)
  {
    this.aliases = this.aliases.concat(...aliases);
  }

  /**
   * Returns whether or not the `name` matches the name and optionally any alias
   * @param {(String|ResourceName)} name The name to compare to
   * @param {boolean=} aliases=true Whether or not it should search within the aliases aswell
   * @return {boolean}
   */
  matchesName(name, aliases = true)
  {
    return this.name.equals(name) || aliases &amp;&amp; this.aliases.includes(name.toString());
  }

  /**
   * Returns the permission required for the `Command`
   * @return {String}
   */
  getPermissionRequired()
  {
    return this.permissionRequired;
  }

  /**
   * Sets the required permission for the `Command`
   * @param {String} permissionRequired The required permission
   * @throws Will throw an Error if the `permissionRequired` is not a String
   */
  setPermissionRequired(permissionRequired)
  {
    if (typeof permissionRequired != "string") {
      throw new Error(`kimiko.js, Command::setPermissionRequired(permissionRequired): 'permissionRequired' should be a string, got ${typeof permissionRequired}.`);
    }
    this.permissionRequired = permissionRequired;
  }

  /**
   * Returns the `executor` of this command, if set
   * @return {?Command#executor}
   */
  getExecutor()
  {
    return this.executor;
  }

  /**
   * Sets the `executor` of this command
   * @param {Command#executor} executor
   * @throws Will throw an Error if the `executor` isn't valid
   */
  setExecutor(executor)
  {
    if (typeof executor != "function") {
      throw new Error(`kimiko.js, Command::setExecutor(executor): 'executor' should be a function.`);
    }
    this.executor = executor;
  }

  /**
   * Returns the tab completion callback of the command, if set
   * @return {?Command#tabCompleter}
   */
  getTabCompleter()
  {
    return this.tabCompleter;
  }

  /**
   * Sets the tab completer of the command
   * @param {Command#tabCompleter} tabCompleter The tab completer callback to be set
   * @throws Will throw an Error if `tabCompleter` isn't valid
   */
  setTabCompleter(tabCompleter)
  {
    if (typeof tabCompleter != "function") {
      throw new Error(`kimiko.js, Command::setTabCompleter(tabCompleter): 'tabCompleter' should be a function.`);
    }
    this.tabCompleter = tabCompleter;
  }

  /**
   * Internal execution function, which you should **NOT** use, unless you don't care about the permission and argument check
   * @private
   * @param {Command~Context} context Context of the command call
   * @param {String} label Name by which the command was called
   * @param {String[]} args Arguments for the call
   * @throws Will throw an error if the command does not have an executor
   * @return {CommandResult}
   */
  _execute(context, label, args = [])
  {
    if (!this.executor) {
      throw new Error(`kimiko.js, Command::_execute(...): Command::executor hasn't been defined yet.`);
    }
    return this.executor(context, this, label, args);
  }

  /**
   * Internal function, checks for the required permission and executes the command's executor through {@link Command#_execute}
   * @private
   * @param {Command~Context} context Context of the command call
   * @param {String} label Name by which the command was called
   * @param {String[]} args Arguments for the call
   * @throws Will throw if `executor` was not set
   * @return {CommandResult} The result of the executor or, if the permissions aren't valid, {@link CommandResult.ERROR_PERMISSION}
   */
  _handleLocalExecution(context, label, args = [])
  {
    if (this.permissionRequired &amp;&amp; !context.hasPermission(this.permissionRequired)) {
      return CommandResult.ERROR_PERMISSION;
    }
    return this._execute(context, label, args);
  }

  /**
   * Execution handler; the function you should call when the command has been invoked. It does argument and permission checks and propagates the call to subCommands
   * @param {Command~Context} context Context of the call
   * @param {String} label Name by which the command was invoked
   * @param {String[]} args Arguments for the command
   * @throws Will throw if the `executor` wasn't set
   * @return {CommandResult} the result of the call. If the arguments are invalid, a {@link CommandResult.ERROR_USAGE} will be returned and if the permissions are invalid, the return value will be {@link CommandResult.ERROR_PERMISSION}.
   */
  handleExecution(context, label, args = [])
  {
    let result = 0;

    if (!args.length) {
      result = this._handleLocalExecution(context, label, args);
    } else {
      let subLabel = args[0];
      let subCommand = this.getSubCommand(subLabel);
      if (subCommand) {
        // no permission check: the subcommand may do it by itself
        return subCommand.handleExecution(context, subLabel, args.slice(1));
      }
      else {
        result = this._handleLocalExecution(context, label, args);
      }
    }

    if (result == CommandResult.ERROR_USAGE)
    {
      let usage = this.getUsage(context.getSender()).replace("&lt;command>", this.getName());
      return [result, usage];
    }

    return [result];
  }

  /**
   * The handler for the tab completion event, it will return all of the possibilities as a String array
   * @param {Command~Context} context Context of the tab completion call
   * @param {String} label Label of the command
   * @param {String[]} args Arguments already typed in
   * @return {String[]} Possible values for the completion
   */
  onTabComplete(context, label, args = [])
  {
    if (args.length == 1) {
      let subCommands = this.getSubCommands();

      if (!subCommands.length) {
        return this.tabCompleter(context, this, label, args);
      }

      let subCommandsArray = subCommands.filter((sc) => {
          let permission = sc.getPermissionRequired();
          return !permission || context.hasPermission(permission);
        })
        .map(sc => sc.getName());

      let additionalCompletion = this.tabCompleter(context, this, label, args);
      if (additionalCompletion) {
        subCommandsArray = subCommandsArray.concat(additionalCompletion)
      }
      return subCommandsArray.filter((sc) => sc.startsWith(args[0])).sort();
    } else {
      let subCommand = this.getSubCommand(args[0]);
      if (subCommand) {
        let permission = subCommand.getPermissionRequired();
        if (!permission || context.hasPermission(permission)) {
          return subCommand.onTabComplete(context, label, args.slice(1));
        }
      }
    }

    return this.tabCompleter(context, this, label, args);
  }

  /**
   * Adds a subCommand to the command, will do nothing if the subCommand already has a parent or if there is already another subCommand with the same name or alias
   * @param {Command} subCommand SubCommand to be added
   */
  addSubCommand(subCommand)
  {
    if (subCommand.hasParent() || this.hasSubCommand(subCommand)) return;
    subCommand.setParent(this);
    this.subCommands.push(subCommand);
  }

  /**
   * Returns whether or not a subCommand is present in the command
   * @param {(String|ResourceName|Command)} subCommand
   * @return {boolean}
   */
  hasSubCommand(subCommand = "")
  {
    if (typeof subCommand == "string" || subCommand instanceof ResourceName) {
      return this.subCommands.find((sc) => sc.matchesName(subCommand));
    } else if (typeof subCommand == "object") {
      return this.subCommands.includes(subCommand);
    }
    return false;
  }

  /**
   * Removes, if present, a subCommand from the command
   * @param {Command} subCommand
   */
  removeSubCommand(subCommand)
  {
    let index = this.subCommands.indexOf(subCommand);
    if (~index) this.subCommands.splice(index, 1); // if the subCommand is present, remove it
  }

  /**
   * Returns, if found, a subCommand matching `label` (name or alias)
   * @param {(String|ResourceName)} label
   */
  getSubCommand(label)
  {
    return this.subCommands.find((sc) => sc.matchesName(label));
  }

  /**
   * Returns all the subCommands of a command
   * @return {Command[]}
   */
  getSubCommands()
  {
    return this.subCommands;
  }
}

/**
 * @callback Command#executor The executor function: the code the command will execute once called
 * @param {Context} context
 * @param {Command} command This `Command`'s instance
 * @param {String} label With which name the `Command` instance was invoked
 * @param {String[]} args The arguments for the command
 * @return {?CommandResult} The result of the command
 */

/**
 * @callback Command#tabCompleter The tab completer function: it will be called within the {@link Command#onTabComplete} handler and should return the possible completions disponible
 * @param {Context} context
 * @param {Command} command This `Command`'s instance
 * @param {String} label With which name the `Command` instance was invoked
 * @param {String[]} args The arguments for the command
 * @return {String[]} The possible completions
 */

/**
 * @callback Command~descriptionCallback
 * @param {*=} sender If given as argument to {@link Command#getDescription}, the sender/author
 * @return {String}
 */

/**
 * @callback Command~usageCallback
 * @param {*=} sender If given as argument to {@link Command#getUsage}, the sender/author
 * @return {String}
 */

/**
 * @typedef {Object} Command~Context A flexible object representing a command call or tab completion context
 * @property {function} hasPermission A function which should return wether or not the sender has a specific permission
 * @property {function} getSender A function which should return the sender of the command call
 */

module.exports = Command;

    </code></pre>
  </article>
</section>

  

    </div>
    
    
    <!--JavaScript at end of body for optimized loading-->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
		<script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js" integrity="sha384-kW+oWsYx3YpxvjtZjFXqazFpA7UP/MbiY4jvs+RWZo2+N94PFZ36T6TFkc9O3qoB" crossorigin="anonymous"></script>
		<script>M.AutoInit();</script>
  </body>
</html>
